# -*- coding: utf-8 -*-
"""
05_backtest_z_filter.py

Backtest a simple execution risk rule:
- Baseline: execute all swaps (as if we were forced to trade)
- Rule: skip trades when z = trade_size_usdc / liquidity_prev exceeds a threshold

We evaluate "execution cost" due to adverse slippage:
- adverse_slippage = max(slippage, 0)
- cost_usdc = trade_size_usdc * adverse_slippage

Data source: SQLite table swaps_features (generated by 03_build_features.py)
"""

import os
import sqlite3
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

DB_PATH = os.getenv("DB_PATH", "data/univ3.db")
TABLE = os.getenv("FEATURE_TABLE", "swaps_features")

# Train/test split by time order
TRAIN_FRAC = float(os.getenv("TRAIN_FRAC", "0.6"))

# Choose threshold by quantile on TRAIN z (e.g., 0.9 means skip top 10% z trades)
Z_Q = float(os.getenv("Z_Q", "0.9"))

# Or override directly with a numeric threshold (if set, this wins)
Z_THRESHOLD = os.getenv("Z_THRESHOLD", "").strip()


def summarize_cost(name: str, cost: pd.Series) -> dict:
    cost = cost.dropna()
    if len(cost) == 0:
        return {"name": name, "n": 0}
    return {
        "name": name,
        "n": int(len(cost)),
        "mean_cost_usdc": float(cost.mean()),
        "median_cost_usdc": float(cost.median()),
        "p95_cost_usdc": float(np.quantile(cost, 0.95)),
        "p99_cost_usdc": float(np.quantile(cost, 0.99)),
        "max_cost_usdc": float(cost.max()),
        "total_cost_usdc": float(cost.sum()),
    }


def main():
    conn = sqlite3.connect(DB_PATH)

    df = pd.read_sql(
        f"""
        SELECT
            block_number,
            log_index,
            z,
            slippage,
            trade_size_usdc
        FROM {TABLE}
        WHERE
            z IS NOT NULL
            AND slippage IS NOT NULL
            AND trade_size_usdc IS NOT NULL
        ORDER BY block_number ASC, log_index ASC
        """,
        conn,
    )
    conn.close()

    print(f"[OK] Loaded rows: {len(df)} from {DB_PATH}:{TABLE}")

    # Clean
    df = df[np.isfinite(df["z"]) & np.isfinite(df["slippage"]) & np.isfinite(df["trade_size_usdc"])]
    df = df[(df["z"] > 0) & (df["trade_size_usdc"] > 0)]
    print(f"[OK] After cleaning: {len(df)} rows")

    # Define adverse slippage cost (USDC)
    df["adverse_slippage"] = df["slippage"].clip(lower=0.0)
    df["cost_usdc"] = df["trade_size_usdc"] * df["adverse_slippage"]

    # Train/test split by time order
    n = len(df)
    split = int(n * TRAIN_FRAC)
    train = df.iloc[:split].copy()
    test = df.iloc[split:].copy()

    if len(train) < 1000 or len(test) < 1000:
        print("[WARN] Small sample in train/test. Consider collecting more swaps for stable tail estimates.")

    # Pick z threshold
    if Z_THRESHOLD:
        z_th = float(Z_THRESHOLD)
        th_src = f"manual Z_THRESHOLD={z_th}"
    else:
        z_th = float(train["z"].quantile(Z_Q))
        th_src = f"train quantile Z_Q={Z_Q} -> z_th={z_th:.6g}"

    print(f"[OK] Threshold: {th_src}")

    # Baseline: execute all trades
    base_cost = test["cost_usdc"]

    # Rule: skip high-z trades (cost becomes 0 because we choose not to trade)
    rule_mask = test["z"] <= z_th
    rule_cost = test.loc[rule_mask, "cost_usdc"]

    # Summaries
    base_stats = summarize_cost("baseline_execute_all", base_cost)
    rule_stats = summarize_cost("rule_execute_if_z<=th", rule_cost)

    # Add execution rate and avoided cost
    executed_rate = float(rule_mask.mean())
    avoided_cost = float(base_cost.sum() - rule_cost.sum())

    print("\n[RESULT] Backtest summary (TEST period):")
    print(pd.DataFrame([base_stats, rule_stats]).to_string(index=False))
    print(f"\n[RESULT] Rule executed fraction: {executed_rate:.2%}")
    print(f"[RESULT] Avoided adverse slippage cost (USDC): {avoided_cost:,.4f}")

    # Plot cost distribution (log scale helps)
    os.makedirs("figures", exist_ok=True)

    plt.figure(figsize=(10, 5))
    plt.hist(base_cost, bins=50, alpha=0.7, label="baseline cost_usdc")
    plt.hist(rule_cost, bins=50, alpha=0.7, label="rule cost_usdc (executed only)")
    plt.yscale("log")
    plt.xlabel("Execution cost (USDC) = trade_size_usdc * max(slippage,0)")
    plt.ylabel("Count (log scale)")
    plt.title("Execution Cost Distribution: Baseline vs z-Filter Rule (Test)")
    plt.legend()
    plt.tight_layout()
    plt.savefig("figures/backtest_cost_hist.png", dpi=150)
    plt.show()

    # Plot tail (p99) vs z threshold sweep (optional quick scan)
    # This helps you choose a nice z threshold for presentation.
    sweep_q = np.linspace(0.5, 0.99, 15)
    rows = []
    for q in sweep_q:
        th = float(train["z"].quantile(q))
        m = test["z"] <= th
        c = test.loc[m, "cost_usdc"]
        if len(c) < 50:
            continue
        rows.append((q, th, float(np.quantile(c, 0.99)), float(c.sum()), float(m.mean())))
    if rows:
        sw = pd.DataFrame(rows, columns=["z_quantile", "z_th", "p99_cost_usdc", "total_cost_usdc", "exec_rate"])
        sw.to_csv("figures/z_threshold_sweep.csv", index=False)

        plt.figure(figsize=(10, 5))
        plt.plot(sw["z_th"], sw["p99_cost_usdc"], marker="o")
        plt.xlabel("z threshold")
        plt.ylabel("p99 execution cost (USDC)")
        plt.title("p99 Cost vs z-threshold (Rule executes when z<=th)")
        plt.grid(True)
        plt.tight_layout()
        plt.savefig("figures/z_threshold_sweep_p99.png", dpi=150)
        plt.show()

        print("[OK] Saved sweep: figures/z_threshold_sweep.csv and figures/z_threshold_sweep_p99.png")


if __name__ == "__main__":
    main()
